clc;
clear all;
close all;

%msg - передаваемое сообщение (11 бит)
msg=[1 1 0 0 1 0 1 0 1 1 1];
%Кодируем msg с помощью кода Хэмминга
%encode(msg,n,k), где n - длина кодового слова, k - длина
%блока сообщения
%Для кода Хэмминга n=2^m-1, k=n-m
%Для примера возьмем m=4=>n=15,k=11
m=4; n=15; k=11;
code_hamming=encode (msg,n,k,'hamming/binary');
%Декодируем, воссоздавая исходное сообщение
decoded_hamming = decode(code_hamming,n,k,'hamming/binary');
%сделаем ошибку при помощи инвертирования одного бита
code_hamming(7) = not(code_hamming(7));
%декодируем сообщение с ошибкой
[decoded_hamming,err] = decode(code_hamming,n,k,'hamming/binary');

%Проведем кодирование/декодирование c помощью создания проверочной 
%и генераторной матрицы, а также вычислим синдром
msg=[1 1 0 0 1 0 1 0 1 1 1];
%[h,g,n,k] = hammgen(...) возвращает проверочную, порождающую
%матрицы и длину кодового слова n и длину блока исходного
%сообщения k
[h,g,n,k] = hammgen(m);
%столбцы порождающей матрицы с номерами не степенями 2 образуют 
% единичную подматрицу, а остальные столбцы соответствуют 
% проверочным уравнениям кода. Такая матрица при кодировании 
% будет копировать биты сообщения в позиции, не степени 2, 
% и заполнять другие позиции кода согласно системе вычисления
% контрольных разрядов.
new_msg=msg*g;
%приведем к бинарному виду путем поэлементного деления массива 
%сообщения на 2 и получения таким образом остатка от деления
new_msg=rem(new_msg,ones(1,n).*2);

%сделаем ошибку при помощи инвертирования одного бита
new_msg(7) = not(new_msg(7));
%вычисоим синдром сообщения с ошибкой
syndrom=new_msg*h';
syndrom=rem(syndrom,ones(1,n-k).*2);

%с помощью матрицы синдрома выявим ошибочный бит и исправим его
% Сначала вычислим таблицу декодирования для кода Хэмминга
%по проверочной таблице
num_error=syndtable(h);

%Преобразуем вектор-строку двоичных цифр матрицы синдрома
%в неотрицательное целое число.
%left-msb-первый столбец - старший разряд
tmp=bi2de(syndrom,'left-msb');
error_col=num_error(tmp+1,:);
new_msg;
rez=xor(new_msg,error_col);
decode_msg=decode(code_hamming,n,k,'hamming/binary');


%Выполним кодирование/декодирование циклическим кодом
msg=[1 1 0 0 1 0 1 0 1 1 1];
pol=cyclpoly(n,k);
[h,g]=cyclgen(n,pol);
code=msg*g;
code=rem(code,ones(1,n).*2);
code(7)=not(code(7));
syndrom=code*h';
syndrom=rem(syndrom, ones(1,n-k).*2);

%с помощью матрицы синдрома выявим ошибочный бит и исправим его
% Сначала вычислим таблицу декодирования для кода Хэмминга
%по проверочной таблице
num_error=syndtable(h);

%Преобразуем вектор-строку двоичных цифр матрицы синдрома
%в неотрицательное целое число.
%left-msb-первый столбец - старший разряд
tmp=bi2de(syndrom,'left-msb');
error_col=num_error(tmp+1,:);
code;
rez=xor(code,error_col);
msg;
msg = decode(code,n,k,'cyclic/binary');

%Произведем кодирование/декодирование при помощи кодов БЧХ
msg=[1 1 0 0 1 0 1 0 1 1 1]

codebch=comm.BCHEncoder(n,k)
decbch=comm.BCHDecoder(n,k)
temp=msg';
code=step(codebch,temp(:))';

code(7)=not(code(7));
decode=step(decbch,code')';
msg;

%Произведем кодирование/декодирование с помощью кодов Рида-Соломона
m=3;%число бит на символ
n=2^m-1;%длина кода слова
k=3;%длина сообщения

msg=gf([2 7 3;4 0 6],m)
%сгенерируем код Рида-Соломона
code=rsenc(msg,n,k)

%добавим ошибки к закодируемому сообщению
errs=gf([0 5 5 0 0 0 0; 0 7 7 7 0 0 0],m);
code=code+errs

%Раскодируем сообщение с ошибками
[dec,errnum]=rsdec(code,n,k)